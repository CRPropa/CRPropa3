"""
- The purpose of this script is to centrally generate all interaction files needed by CRPropa
  from a photonField.txt file
- This script has incorporated all calc_<interaction> files contained in the GitHub repository

    https://github.com/CRPropa/CRPropa3-data

  thus credit goes to the authors of the respective code writers.
- Multi-core processing is now supported
- NOTE: spectrum_<fieldName>.txt for ~/src/crpropa/ElectronPairProduction can NOT be 
  generated by this script, as this appears to get constructed from data provided by 
  CRPropa2 scripts. As all spectrum scripts appear to only continue zeros or values
  *very* close to zero, a copy of spectrum_CMB.txt should be used.
- Data generated by this script have to be written to their proper locations in
  ~/share/crpropa/
- written by Mario HÃ¶rbe (mario.hoerbe@rub.de)


Usage:
  generate_tabFiles.py <fromFile> <toDirectory>
  generate_tabFiles.py -h | --help
  generate_tabFiles.py --version

Arguments:
  <fromFile>        path/to/photonField.txt
  <toDirectory>     ~/CRPropa/share/crpropa/

Options:
   -h, --help       Show this message.
   --version        Print the version.
"""


from __future__ import division
from multiprocessing import Process, cpu_count, Pool
import multiprocessing
import os
import sys
from joblib import Parallel, delayed
import numpy as np
from scipy import integrate
from scipy.integrate import cumtrapz, romb
from docopt import docopt

eV = 1.60217657e-19  # [J]
erg = 1e-7  # [J]
c0 = 299792458  # [m/s]
h = 6.62606957e-34  # [m^2 kg / s]
kB = 1.3806488e-23  # [m^2 kg / s^2 / K]
Mpc = 3.08567758e22  # [m]


                # arr  arr  arr 
def calc_rate_eps(eps, xs, gamma, field, z=0, cdf=False):
    """
    Calculate the interaction rate for given tabulated cross sections against an isotropic photon background.
    The tabulated cross sections need to be of length n = 2^i + 1 and the tabulation points log-linearly spaced.

    eps   : tabulated photon energies [J] in nucleus rest frame
    xs    : tabulated cross sections [m^2]
    gamma : (array of) nucleus Lorentz factors
    field : photon background, see photonField.py
    z     : redshift
    cdf   : calculate cumulative differential rate

    Returns :
        interaction rate 1/lambda(gamma) [1/Mpc] or
        cumulative differential rate d(1/lambda)/d(s_kin) [1/Mpc/J^2]
    """
    F = cumtrapz(x=eps, y=eps * xs, initial=0)
    n = field.getDensity(np.outer(1. / (2 * gamma), eps), z)
    if cdf:
        y = n * F / eps**2
        return cumtrapz(x=eps, y=y, initial=0) / np.expand_dims(gamma, -1) * Mpc
    else:  # Branch of interest
        y = n * F / eps
        dx = mean_log_spacing(eps)
        return romb(y, dx=dx) / gamma * Mpc


def calc_rate_s(s_kin, xs, E, field, z=0, cdf=False):
    """
    Calculate the interaction rate for given tabulated cross sections against an isotropic photon background.
    The tabulated cross sections need to be of length n = 2^i + 1 and the tabulation points log-linearly spaced.

    s_kin : tabulated (s - m**2) for cross sections [J^2]
    xs    : tabulated cross sections [m^2]
    E     : (array of) cosmic ray energies [J]
    field : photon background, see photonField.py
    z     : redshift
    cdf   : calculate cumulative differential rate

    Returns :
        interaction rate 1/lambda(gamma) [1/Mpc] or
        cumulative differential rate d(1/lambda)/d(s_kin) [1/Mpc/J^2]
    """
    F = cumtrapz(x=s_kin, y=s_kin * xs, initial=0)
    n = field.getDensity(np.outer(1. / (4 * E), s_kin), z)
    if cdf:
        y = n * F / s_kin**2
        return cumtrapz(x=s_kin, y=y, initial=0) / 2 / np.expand_dims(E, -1) * Mpc
    else:
        y = n * F / s_kin
        ds = mean_log_spacing(s_kin)
        return romb(y, dx=ds) / 2 / E * Mpc


def mean_log_spacing(x):
    """ <Delta log(x)> """
    return np.mean(np.diff(np.log(x)))


def romb_truncate(x, n):
    """ Truncate array to largest size n = 2^i + 1 """
    i = int(np.floor(np.log2(n))) + 1
    return x[0:2**i + 1]


def romb_pad_zero(x, n):
    """ Pad array with zeros """
    npad = n - len(x)
    return np.r_[x, np.zeros(npad)]


def romb_pad_logspaced(x, n):
    """ Pad array with log-linear increasing values """
    npad = n - len(x)
    dlx = np.mean(np.diff(np.log(x)))
    xpad = x[-1] * np.exp(dlx * np.arange(1, npad + 1))
    return np.r_[x, xpad]



class photonField:
    """ customizable photon field """

    def __init__(self, fromFile, photonFieldName):
        self.name = photonFieldName
        self.info = os.path.basename(fromFile)
        self.redshift, self.fieldData, self.Emin, self.Emax = self.read_photonField(fromFile)
        

    def read_photonField(self, fromFile):
        """ read in tabulated photonField file """
        inData = []
        with open(fromFile, "r") as inFile:
            for line in inFile:
                if "#" in line:
                    continue
                data = list(line.split())
                data = [float(d) for d in data]
                inData.append(data)

        energy = np.array(inData[0])
        Emin = energy[0] * eV  # [J]
        Emax = energy[-1] * eV  # [J]
        redshift = inData[1]
        density = np.array(inData[2:])

        data = {}  # dictionary {redshift : (eps, dn/deps)}
        for i,z in enumerate(redshift):
            data[z] = energy, density[:,i]
        return redshift, data, Emin, Emax


    def getDensity(self, eps, z=0):
        """
        Comoving spectral number density dn/deps [1/m^3/J] at given photon energy eps [J] and redshift z.
        Multiply with (1+z)^3 for the physical number density.
        """
        eps /= eV  # J -> eV
        if z == 0:
            z = np.min(self.redshift)
        return np.interp(eps, self.fieldData[z][0], self.fieldData[z][1]) * 6.241509e24  # 1/eVcm^3 -> 1/Jm^3


    def getEmin(self):
        """Minimum effective photon energy in [J]"""
        return self.Emin
        # return self.fieldData[z][0][0] * eV


    def getEmax(self):
        """Maximum effective photon energy in [J]"""
        return self.Emax
        # return self.fieldData[z][0][-1] * eV


class Interactions:
    """
    Class containing all interaction calculations that provide shared .txt data to CRPropa
    """

    def calc_elasticscattering(fields, writeFilesTo):
        # output folder
        folder = writeFilesTo + 'ElasticScattering'
        if not os.path.exists(folder):
            os.makedirs(folder)

        gamma = np.logspace(6, 14, 201)  # tabulated UHECR Lorentz-factors

        # load cross section data from TALYS
        ddir = 'tables/PD_Talys1.8_Khan/'
        eps = np.genfromtxt(ddir + 'eps_elastic.txt') * eV * 1e6  # nuclear rest frame photon energies [J]
        data = np.genfromtxt(ddir + 'xs_elastic.txt', dtype=[('Z', int), ('N', int), ('xs', '%if8' % len(eps))])

        # only consider TALYS cross sections for A >= 12
        idx = (data['Z'] + data['N']) >= 12
        data = data[idx]

        # factor out the principal scaling given by the TRK formula: sigma_int ~ Z*N/A
        data['xs'] /= (data['Z'] * data['N'] / (data['Z'] + data['N']))[:, np.newaxis]

        # pad cross sections to next larger 2^n + 1 tabulation points for Romberg integration
        eps = romb_pad_logspaced(eps, 513)
        xs = np.array([romb_pad_zero(x, 513) for x in data['xs']]) * 1e-31

        for field in fields:

            # calculate the interaction rate, averaged over all isotopes
            ncores = cpu_count()
            with Parallel(ncores, verbose=0) as pool:

                rate = list(
                    pool(
                        delayed(calc_rate_eps)(eps, x, gamma, field) for x in xs
                        )
                    )
            rate = np.mean(rate, axis=0)
            
            fname = folder + '/rate_%s.txt' % field.name.split('_')[0][:3] # [:3] added to be readable by respective .cpp file
            header = 'Average interaction rate for elastic scattering of %s photons off nuclei\nScale with Z*N/A for nuclei\n1/lambda [1/Mpc] for log10(gamma) = 6-14 in 201 steps' % field.info
            np.savetxt(fname, rate, fmt='%g', header=header)

            with Parallel(ncores, verbose=0) as pool:

                C = list(
                    pool(
                        delayed(calc_rate_eps)(eps, x, gamma, field, cdf=True) for x in xs
                        )
                    )
            C = [c/np.max(c, axis=1, keepdims=True) for c in C]
            CDF = np.zeros((len(gamma), len(eps)))
            for c in C:
                CDF += c
            
            CDF /= len(data)
            CDF = np.nan_to_num(CDF)

            fname = folder + '/cdf_%s.txt' % field.name.split('_')[0][:3] # [:3] added to be readable by respective .cpp file 
            data = np.c_[np.log10(gamma), CDF]
            fmt = '%g' + '\t%g' * len(eps)
            header = '# Average CDF(background photon energy) for elastic scattering with the photon field defined in %s\n# log10(gamma), (1/lambda)_cumulative for eps = log10(2 keV) - log10(263 MeV) in 513 steps' % field.info
            np.savetxt(fname, data, fmt=fmt, header=header)


    def calc_electromagnetic(fields, writeFilesTo):

        me2 = (510.998918E3 * eV)**2  # squared electron mass [J^2/c^4]
        sigmaThompson = 6.6524E-29  # Thompson cross section [m^2]
        alpha = 1 / 137.035999074  # fine structure constant

        def sigmaPP(s):
            """ Pair production cross section (Bethe-Heitler), see Lee 1996 """
            smin = 4 * me2
            if (s < smin):
                return 0
            else:
                b = np.sqrt(1 - smin / s)
                return sigmaThompson * 3 / 16 * (1 - b**2) * ((3 - b**4) * np.log((1 + b) / (1 - b)) - 2 * b * (2 - b**2))


        def sigmaDPP(s):
            """ Double-pair production cross section, see R.W. Brown eq. (4.5) with k^2 = q^2 = 0 """
            smin = 16 * me2
            if (s < smin):
                return 0
            else:
                return 6.45E-34 * (1 - smin / s)**6


        def sigmaICS(s):
            """ Inverse Compton scattering cross sections, see Lee 1996 """
            smin = me2
            if (s < smin):  # numerically unstable close to smin
                return 0
            else:
                # note: formula unstable for (s - smin) / smin < 1E-5
                b = (s - smin) / (s + smin)
                A = 2 / b / (1 + b) * (2 + 2 * b - b**2 - 2 * b**3)
                B = (2 - 3 * b**2 - b**3) / b**2 * np.log((1 + b) / (1 - b))
                return sigmaThompson * 3 / 8 * smin / s / b * (A - B)
 

        def sigmaTPP(s):
            """ Triplet-pair production cross section, see Lee 1996 """
            beta = 28 / 9 * np.log(s / me2) - 218 / 27
            if beta < 0:
                return 0
            else:
                return sigmaThompson * 3 / 8 / np.pi * alpha * beta


        def getTabulatedXS(sigma, skin):
            """ Get crosssection for tabulated s_kin """
            if sigma in (sigmaPP, sigmaDPP):  # photon interactions
                return np.array([sigma(s) for s in skin])
            if sigma in (sigmaTPP, sigmaICS):  # electron interactions
                return np.array([sigma(s) for s in skin + me2])
            return False


        def getSmin(sigma):
            """ Return minimum required s_kin = s - (mc^2)^2 for interaction """
            return {sigmaPP: 4 * me2,
                    sigmaDPP: 16 * me2,
                    sigmaTPP: np.exp((218 / 27) / (28 / 9)) * me2 - me2,
                    sigmaICS: 1E-9 * me2
                    }[sigma]


        def getEmin(sigma, field):
            """ Return minimum required cosmic ray energy for interaction *sigma* with *field* """
            return getSmin(sigma) / 4 / field.getEmax()


        def process(sigma, field, name):
            # output folder
            folder = writeFilesTo + name
            if not os.path.exists(folder):
                os.makedirs(folder)

            # tabulated energies, limit to energies where the interaction is possible
            Emin = getEmin(sigma, field)
            E = np.logspace(10, 23, 261) * eV
            E = E[E > Emin]

            # -------------------------------------------
            # calculate interaction rates
            # -------------------------------------------
            # tabulated values of s_kin = s - mc^2
            # Note: integration method (Romberg) requires 2^n + 1 log-spaced tabulation points
            s_kin = np.logspace(6, 23, 2049) * eV**2
            xs = getTabulatedXS(sigma, s_kin)
            rate = calc_rate_s(s_kin, xs, E, field)

            # save
            fname = folder + '/rate_%s.txt' % field.name
            data = np.c_[np.log10(E / eV), rate]
            fmt = '%.2f\t%.6g'
            header = '%s interaction rates\nphoton field: %s\nlog10(E/eV), 1/lambda [1/Mpc]' % (name, field.info)
            np.savetxt(fname, data, fmt=fmt, header=header)

            # -------------------------------------------
            # calculate cumulative differential interaction rates for sampling s values
            # -------------------------------------------
            # find minimum value of s_kin
            skin1 = getSmin(sigma)  # s threshold for interaction
            skin2 = 4 * field.getEmin() * E[0]  # minimum achievable s in collision with background photon (at any tabulated E)
            skin_min = max(skin1, skin2)

            # tabulated values of s_kin = s - mc^2, limit to relevant range
            # Note: use higher resolution and then downsample
            skin = np.logspace(6.2, 23, 1680 + 1) * eV**2
            skin = skin[skin > skin_min]

            xs = getTabulatedXS(sigma, skin)
            rate = calc_rate_s(skin, xs, E, field, cdf=True)

            # downsample
            skin_save = np.logspace(6.2, 23, 168 + 1) * eV**2
            skin_save = skin_save[skin_save > skin_min]
            rate_save = np.array([np.interp(skin_save, skin, r) for r in rate])

            # save
            data = np.c_[np.log10(E / eV), rate_save]  # prepend log10(E/eV) as first column
            row0 = np.r_[0, np.log10(skin_save / eV**2)][np.newaxis]
            data = np.r_[row0, data]  # prepend log10(s_kin/eV^2) as first row

            fname = folder + '/cdf_%s.txt' % field.name
            fmt = '%.2f' + '\t%.6g' * np.shape(rate_save)[1]
            header = '%s cumulative differential rate\nphoton field: %s\nlog10(E/eV), d(1/lambda)/ds_kin [1/Mpc/eV^2] for log10(s_kin/eV^2) as given in first row' % (name, field.info)
            np.savetxt(fname, data, fmt=fmt, header=header)

        for field in fields:

            process(sigmaPP, field, "EMPairProduction")
            process(sigmaPP, field, "EMDoublePairProduction")
            process(sigmaPP, field, "EMTripletPairProduction")
            process(sigmaPP, field, "EMInverseComptonScattering")

    def calc_pairproduction(fields, writeFilesTo):
        """
        Calculate the energy loss rate through electron pair production
        References:
        (B70) Blumenthal 1970, Phys.Rev. D
        (C92) Chodorowski et al. 1992, ApJ 400:181-185
        """

        Mpc = 3.08567758e22  # [m]
        r0 = 2.817940e-15  # classical electron radius [m]
        alpha = 7.297352e-3  # fine-structure constant
        me = 9.10938291e-31  # electron mass [kg]
        me_c2 = me * c0**2  # electron mass in [J/c^2]
        mp = 1.67262178e-27  # proton mass [kg]


        def lossRate(gamma, field, z=0):
            """
            Loss rate from electron pair production with the photon field defined in given photon background, cf. C92, equation 3.11
            gamma   : list of nucleus Lorentz factors
            field   : photon background
            z       : redshift
            Returns : 1/gamma dgamma/dx [1/Mpc]
            """

            def phi(k):
                """
                Parametrization of the integral 3.12 (C92)
                """
                _c = np.array([0.8048, 0.1459, 1.137e-3, -3.879e-6])
                _d = np.array([-86.07, 50.96, -14.45, 8 / 3.])
                _f = np.array([2.910, 78.35, 1837])
                # phi(k) for k < 25, eq. 3.14
                if k < 25:
                    return np.pi / 12 * (k - 2)**4 / (1 + sum(_c * (k - 2)**np.arange(1, 5)))
                # phi(k) for k > 25, eq. 3.18 and 3.16
                return k * sum(_d * np.log(k)**np.arange(4)) / (1 - sum(_f * k**-np.arange(1, 4)))

            def integrand(logk, gamma, field):
                """
                Integrand of equation 3.11 (C92), logarithmic version
                logk  : ln(k) = ln(2 gamma eps / (me c^2)), photon energy
                gamma : nucleus Lorentz factor
                field : photon background
                """
                k = np.exp(logk)
                eps = k * me_c2 / 2 / gamma  # photon energy [J] in lab frame
                n = field.getDensity(eps, z)  # spectral number density [1/m^3/J]
                n *= me_c2  # from substitution d eps / d k
                return n * phi(k) / k  # includes *k from substitution k -> ln(k)

            rate = np.zeros_like(gamma)
            err = np.zeros_like(gamma)
            # minimum and maximum energy of the fields photons in units of me*c^2
            epsmin = field.getEmin() / me_c2
            epsmax = field.getEmax() / me_c2

            for i, g in enumerate(gamma):
                lkmin = np.log(max(2, 2 * g * epsmin))
                lkmax = np.log(2 * g * epsmax)
                lksep = np.linspace(lkmin, lkmax, 11)[1:-1]
                rate[i], err[i] = integrate.quad(
                    integrand, lkmin, lkmax, points=lksep, args=(g, field))

            # prefactor of equation 3.11 (C92) and conversion [1/s] --> [1/Mpc]
            a = alpha * r0**2 * me / mp * Mpc
            return a * rate / gamma, a * err / gamma

        # -------------------------------------------------
        # Generate tables for energy loss rate
        # -------------------------------------------------
        gamma = np.logspace(6, 14, 161)  # tabulated Lorentz factors

        folder = writeFilesTo + 'ElectronPairProduction'
        if not os.path.exists(folder):
            os.makedirs(folder)

        for field in fields:

            rate = lossRate(gamma, field)[0]
            s = (rate > 1e-12)  # truncate if loss rate is < 10^-12 / Mpc

            fname = folder + '/lossrate_%s.txt' % field.name
            data = np.c_[np.log10(gamma[s]), rate[s]]
            fmt = '%.2f\t%.6e'
            header = 'Loss rate for electron-pair production with the photon field defined in %s\nlog10(gamma)\t1/gamma dgamma/dx [1/Mpc]' % field.info
            np.savetxt(fname, data, fmt=fmt, header=header)


    def calc_photodisintigration(fields, writeFilesTo):

        gamma = np.logspace(6, 14, 201)  # tabulated UHECR Lorentz-factors
        
        # ----------------------------------------------------
        # Load cross sections for A < 12
        # ----------------------------------------------------
        ddir1 = 'tables/PD_external/'
        isotopes1 = np.genfromtxt(ddir1 + 'isotopes.txt')
        eps = np.genfromtxt(ddir1 + 'eps.txt')
        d1sum = np.genfromtxt(ddir1 + 'xs_sum.txt', dtype=[('Z', int), ('N', int), ('xs', '%if8' % len(eps))])
        d1exc = np.genfromtxt(ddir1 + 'xs_excl.txt', dtype=[('Z', int), ('N', int), ('ch', int), ('xs', '%if8' % len(eps))])
        # Pad cross sections to next larger 2^n + 1 tabulation points for Romberg integration and convert to SI units
        eps1 = romb_pad_logspaced(eps, 513) * eV * 1e6
        xs1sum = np.array([romb_pad_zero(x, 513) for x in d1sum['xs']]) * 1e-31
        xs1exc = np.array([romb_pad_zero(x, 513) for x in d1exc['xs']]) * 1e-31

        # ----------------------------------------------------
        # Load cross sections for A >= 12 (TALYS)
        # ----------------------------------------------------
        ddir2 = 'tables/PD_Talys1.8_Khan/'
        isotopes2 = np.genfromtxt(ddir2 + 'isotopes.txt')
        eps = np.genfromtxt(ddir2 + 'eps.txt')
        d2sum = np.genfromtxt(ddir2 + 'xs_pd_sum.txt', dtype=[('Z', int), ('N', int), ('xs', '%if8' % len(eps))])
        d2exc = np.genfromtxt(ddir2 + 'xs_pd_thin.txt', dtype=[('Z', int), ('N', int), ('ch', int), ('xs', '%if8' % len(eps))])
        # Only consider cross sections for A > 12
        d2sum = d2sum[(d2sum['Z'] + d2sum['N']) >= 12]
        d2exc = d2exc[(d2exc['Z'] + d2exc['N']) >= 12]
        # Pad cross sections to next larger 2^n + 1 tabulation points for Romberg integration and convert to SI units
        eps2 = romb_pad_logspaced(eps, 513) * eV * 1e6
        xs2sum = np.array([romb_pad_zero(x, 513) for x in d2sum['xs']]) * 1e-31
        xs2exc = np.array([romb_pad_zero(x, 513) for x in d2exc['xs']]) * 1e-31

        # ----------------------------------------------------
        # Load cross sections with photon emission
        # ----------------------------------------------------
        d3sum = np.genfromtxt(ddir2 + 'xs_photon_sum.txt', dtype=[('Z', int), ('N', int), ('Zd', int), ('Nd', int), ('xs', '%if8' % len(eps))])
        d3exc = np.genfromtxt(ddir2 + 'xs_photon_thin.txt', dtype=[('Z', int), ('N', int), ('Zd', int), ('Nd', int), ('Ephoton', float), ('xs', '%if8' % len(eps))])
        # Pad cross sections to next larger 2^n + 1 tabulation points for Romberg integration and convert to SI units
        eps3 = eps2
        xs3sum = np.array([romb_pad_zero(x, 513) for x in d3sum['xs']]) * 1e-31
        xs3exc = np.array([romb_pad_zero(x, 513) for x in d3exc['xs']]) * 1e-31


        def calc_interaction_rates_and_branching_ratios(fields):

            for field in fields:

                # output folder
                folder = writeFilesTo + 'Photodisintegration'
                if not os.path.exists(folder):
                    os.makedirs(folder)

                # Calculate total interaction rates
                R1 = np.array([calc_rate_eps(eps1, x, gamma, field) for x in xs1sum])
                R2 = np.array([calc_rate_eps(eps2, x, gamma, field) for x in xs2sum])

                np.savetxt(
                    folder + '/rate_%s.txt' % field.name,
                    np.r_[np.c_[d1sum['Z'], d1sum['N'], R1], np.c_[d2sum['Z'], d2sum['N'], R2]],
                    fmt='%i\t%i' + '\t%g' * 201,
                    header='Photodisintegration by the %s\nZ, N, 1/lambda [1/Mpc] for log10(gamma) = 6-14 in 201 steps' % field.info)

                # Calculate branching ratios from exclusive interaction rates
                B1 = np.array([calc_rate_eps(eps1, x, gamma, field) for x in xs1exc])
                B2 = np.array([calc_rate_eps(eps2, x, gamma, field) for x in xs2exc])
                for (Z, N, A) in isotopes1:
                    s = (d1exc['Z'] == Z) * (d1exc['N'] == N)
                    B1[s] /= sum(B1[s])
                for (Z, N, A) in isotopes2:
                    s = (d2exc['Z'] == Z) * (d2exc['N'] == N)
                    B2[s] /= sum(B2[s])
                B1 = np.nan_to_num(B1)  # set to 0 when total cross section is 0
                B2 = np.nan_to_num(B2)

                np.savetxt(
                    folder + '/branching_%s.txt' % field.name,
                    np.r_[np.c_[d1exc['Z'], d1exc['N'], d1exc['ch'], B1], np.c_[d2exc['Z'], d2exc['N'], d2exc['ch'], B2]],
                    fmt='%i\t%i\t%06d' + '\t%g' * 201,
                    header='Photo-disintegration with the photon field defined in %s\nZ, N, channel, branching ratio for log10(gamma) = 6-14 in 201 steps' % field.info)


        def calc_photon_emmission_probablilities(fields):

            for field in fields:

                ncores = cpu_count()
                with Parallel(ncores, verbose=10) as pool:
                
                    R3 = list(
                        pool(
                            delayed(calc_rate_eps)(eps3, x, gamma, field) for x in xs3sum
                            )
                        )
                with Parallel(ncores, verbose=10) as pool:
                
                    B3 = list(
                        pool(
                            delayed(calc_rate_eps)(eps3, x, gamma, field) for x in xs3exc
                            )
                        )
                R3 = np.array(R3)
                B3 = np.array(B3)
                
                for i in range(len(d3sum)):
                    s = (d3exc['Z'] == d3sum['Z'][i]) * (d3exc['N'] == d3sum['N'][i]) * (d3exc['Zd'] == d3sum['Zd'][i]) * (d3exc['Nd'] == d3sum['Nd'][i])
                    B3[s] /= R3[i]
                B3 = np.nan_to_num(B3)
                
                np.savetxt(
                    (writeFilesTo + 'Photodisintegration/photon_emission_%s.txt') % field.name.split('_')[0],
                    np.c_[d3exc['Z'], d3exc['N'], d3exc['Zd'], d3exc['Nd'], d3exc['Ephoton'] * 1e6, B3],
                    fmt='%i\t%i\t%i\t%i\t%g' + '\t%g' * 201,
                    header='Emission probabilities of photons with discrete energies via photo-disintegration with the photon field defined in %s\nZ, N, Z_daughter, N_daughter, Ephoton [eV], emission probability for log10(gamma) = 6-14 in 201 steps' % field.info)

        Process(target=calc_interaction_rates_and_branching_ratios, args=([fields])).start()
        Process(target=calc_photon_emmission_probablilities, args=([fields])).start()
        

    def calc_photopionproduction(fields, writeFilesTo):
        lgamma = np.linspace(6, 16, 251)  # tabulated Lorentz factors
        gamma = 10**lgamma

        # ----------------------------------------------------
        # Load proton / neutron cross sections [1/m^2] for tabulated energies [J]
        # truncate to largest length 2^i + 1 for Romberg integration
        # ----------------------------------------------------
        d = np.genfromtxt('tables/PPP/xs_proton.txt', unpack=True)
        eps1 = d[0, :2049] * 1e9 * eV  # [J]
        xs1 = d[1, :2049] * 1e-34  # [m^2]

        d = np.genfromtxt('tables/PPP/xs_neutron.txt', unpack=True)
        eps2 = d[0, :2049] * 1e9 * eV  # [J]
        xs2 = d[1, :2049] * 1e-34  # [m^2]

        for field in fields:

            # output folder
            folder = writeFilesTo + 'PhotoPionProduction'
            if not os.path.exists(folder):
                os.makedirs(folder)

            # ----------------------------------------------------
            # calculate interaction rates at z=0, default option
            # ----------------------------------------------------
            with Parallel(2, verbose=0) as pool:

                r = list(
                    pool(
                        delayed(calc_rate_eps)(e, x, gamma, field) for e,x in [(eps1,xs1),(eps2,xs2)]
                        )
                    )

            r1 = r[0]
            r2 = r[1]
                
            fname = folder + '/rate_%s.txt' % field.name
            data = np.c_[lgamma, r1, r2]
            # fmt = '%.2f\t%.6e\t%.6e'
            # header = ("Photo-pion interaction rate with the photon field defined in %s\nlog10(gamma)"
                      # "\t1/lambda_proton [1/Mpc]\t1/lambda_neutron [1/Mpc]" % field.info)
            # np.savetxt(fname, data, fmt=fmt, header=header)

            # ----------------------------------------------------
            # calculate redshift dependent interaction rates
            # ----------------------------------------------------
            redshifts = field.redshift
            if redshifts is None:
                continue  # skip CMB
            if len(redshifts) > 100:
                redshifts = redshifts[::10]  # thin out long redshift lists (Finke10)

            data = []
            for z in redshifts:
                r1 = calc_rate_eps(eps1, xs1, gamma, field, z)
                r2 = calc_rate_eps(eps2, xs2, gamma, field, z)
                data.append(np.c_[[z] * len(lgamma), lgamma, r1, r2])

            data = np.concatenate([d for d in data], axis=0)
            np.nan_to_num(data)
            fname = folder + '/rate_%s.txt' % field.name
            fmt = '%.2f\t%.2f\t%.6e\t%.6e'
            header = ("Photo-pion interaction rate for the %s\n (redshift dependent)"
                      "z\tlog10(gamma)\t1/lambda_proton [1/Mpc]\t1/lambda_neutron [1/Mpc]" % field.info)
            np.savetxt(fname, data, fmt=fmt, header=header)


def generatePhotonFieldFiles(fromFile, photonFieldName, writeFilesTo):
    """ launch calculation methods """
    if photonFieldName not in ["PF1","PF2","PF3","PF4","PF5","PF6","PF7","PF8"]:
        sys.exit("Error: argument photonFieldName must be either PF1, PF2, ..., PF8 \n but is {}".format(photonFieldName))

    fields = [photonField(fromFile, photonFieldName)]
    if not os.path.exists(writeFilesTo):
        os.makedirs(writeFilesTo)

    for name, method in Interactions.__dict__.items():
        if callable(method):
            Process(target=method, args=(fields, writeFilesTo)).start()


if __name__ == "__main__":

    arguments = docopt(__doc__, version='01/19')

    generatePhotonFieldFiles(fromFile=arguments["<fromFile>"],
                             photonFieldName=os.path.basename(arguments["<fromFile>"])[:-4],
                             writeFilesTo=arguments["<toDirectory>"] )
