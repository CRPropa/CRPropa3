
.. _program_listing_file_include_crpropa_Source.h:

Program Listing for File Source.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_crpropa_Source.h>` (``include/crpropa/Source.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef CRPROPA_SOURCE_H
   #define CRPROPA_SOURCE_H
   
   #include "crpropa/Candidate.h"
   #include "crpropa/Grid.h"
   #include "crpropa/EmissionMap.h"
   #include "crpropa/massDistribution/Density.h"
   
   
   #include <vector>
   
   namespace crpropa {
   class SourceFeature: public Referenced {
   protected:
           std::string description;
   public:
           virtual void prepareParticle(ParticleState& particle) const {};
           virtual void prepareCandidate(Candidate& candidate) const;
           std::string getDescription() const;
   };
   
   
   class SourceInterface : public Referenced {
   public:
           virtual ref_ptr<Candidate> getCandidate() const = 0;
           virtual std::string getDescription() const = 0;
   };
   
   
   class Source: public SourceInterface {
           std::vector<ref_ptr<SourceFeature> > features;
   public:
           void add(SourceFeature* feature);
           ref_ptr<Candidate> getCandidate() const;
           std::string getDescription() const;
   };
   
   
   class SourceList: public SourceInterface {
           std::vector<ref_ptr<Source> > sources;
           std::vector<double> cdf;
   public:
           void add(Source* source, double weight = 1);
           ref_ptr<Candidate> getCandidate() const;
           std::string getDescription() const;
   };
   
   
   class SourceParticleType: public SourceFeature {
           int id;
   public:
           SourceParticleType(int id);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceMultipleParticleTypes: public SourceFeature {
           std::vector<int> particleTypes;
           std::vector<double> cdf;
   public:
           SourceMultipleParticleTypes();
           void add(int id, double weight = 1);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceEnergy: public SourceFeature {
           double E;
   public:
           SourceEnergy(double energy);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourcePowerLawSpectrum: public SourceFeature {
           double Emin;
           double Emax;
           double index;
   public:
           SourcePowerLawSpectrum(double Emin, double Emax, double index);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceComposition: public SourceFeature {
           double Emin;
           double Rmax;
           double index;
           std::vector<int> nuclei;
           std::vector<double> cdf;
   public:
           SourceComposition(double Emin, double Rmax, double index);
           void add(int id, double abundance);
           void add(int A, int Z, double abundance);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourcePosition: public SourceFeature {
           Vector3d position; 
   public:
           SourcePosition(Vector3d position);
           SourcePosition(double d);
           void prepareParticle(ParticleState &state) const;
           void setDescription();
   };
   
   
   class SourceMultiplePositions: public SourceFeature {
           std::vector<Vector3d> positions;
           std::vector<double> cdf;
   public:
           SourceMultiplePositions();
           void add(Vector3d position, double weight = 1);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceUniformSphere: public SourceFeature {
           Vector3d center;
           double radius;
   public:
           SourceUniformSphere(Vector3d center, double radius);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceUniformHollowSphere: public SourceFeature {
           Vector3d center;
           double radius_inner;
           double radius_outer;
   public:
           SourceUniformHollowSphere(Vector3d center,
                           double radius_inner, double radius_outer);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceUniformShell: public SourceFeature {
           Vector3d center;
           double radius;
   public:
           SourceUniformShell(Vector3d center, double radius);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceUniformBox: public SourceFeature {
           Vector3d origin;        // lower box corner
           Vector3d size;          // sizes along each coordinate axes.
   public:
           SourceUniformBox(Vector3d origin, Vector3d size);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceUniformCylinder: public SourceFeature {
           Vector3d origin;        // central point of cylinder 
           double height;          // total height of the cylinder along z-axis. Half over/under the center.
           double radius;          // radius of the cylinder in the xy-plane
   public:
           SourceUniformCylinder(Vector3d origin, double height, double radius);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceSNRDistribution: public SourceFeature {
           double rEarth; // parameter given by observation
           double alpha; // parameter to shift the maximum in R direction
           double beta; // parameter to shift the maximum in R direction
           double zg; // exponential cut parameter in z direction
           double frMax; // helper for efficient sampling
           double fzMax; // helper for efficient sampling
           double rMax; // maximum radial distance - default 20 kpc 
                         // (due to the extension of the JF12 field)
           double zMax; // maximum distance from galactic plane - default 5 kpc
           void setFrMax(); // calculate frMax with the current parameter. 
   
   public:
           SourceSNRDistribution();
           SourceSNRDistribution(double rEarth,double alpha, double beta, double zg);
   
           void prepareParticle(ParticleState &particle) const;
           double fr(double r) const;
           double fz(double z) const;
   
           void setFzMax(double Zg);
   
           void setRMax(double rMax);
   
           void setZMax(double zMax);
   
           // parameter for the raidal distribution
           void setAlpha(double a);
           // parameter for the exponential cut-off in the radial distribution
           void setBeta(double b);
           double getFrMax() const;
           double getFzMax() const;
           double getRMax() const;
           double getZMax() const;
           double getAlpha() const;
           double getBeta() const;
           void setDescription();
   };
   
   
   class SourcePulsarDistribution: public SourceFeature {
           double rEarth; // parameter given by observation
           double beta; // parameter to shift the maximum in R direction
           double zg; // exponential cut parameter in z direction
           double frMax; // helper for efficient sampling
           double fzMax; // helper for efficient sampling
           double rMax; // maximum radial distance - default 22 kpc 
           double zMax; // maximum distance from galactic plane - default 5 kpc
           double rBlur; // relative smearing factor for the radius
           double thetaBlur; // smearing factor for the angle. Unit = [1/length]
   public:
           SourcePulsarDistribution();     
           SourcePulsarDistribution(double rEarth, double beta, double zg, double rBlur, double thetaBlur);
           void prepareParticle(ParticleState &particle) const;
   
           double fr(double r) const;
           double fz(double z) const;
           double ftheta(int i, double r) const;
           double blurR(double r_tilde) const;
           double blurTheta(double theta_tilde, double r_tilde) const;
           void setFrMax(double R, double b);
           void setFzMax(double zg);
           void setRMax(double rMax);
           void setZMax(double zMax);
           void setRBlur(double rBlur);
           void setThetaBlur(double thetaBlur);
           double getFrMax();
           double getFzMax();
           double getRMax();
           double getZMax();
           double getRBlur();
           double getThetaBlur();
           void setDescription();
   };
   
   
   class SourceUniform1D: public SourceFeature {
           double minD; // minimum light-travel distance
           double maxD; // maximum light-travel distance
           bool withCosmology;     // whether to account for cosmological effects (expansion of the Universe)
   public:
           SourceUniform1D(double minD, double maxD, bool withCosmology = true);
           void prepareParticle(ParticleState& particle) const;
           void setDescription();
   };
   
   
   class SourceDensityGrid: public SourceFeature {
           ref_ptr<Grid1f> grid;
   public:
           SourceDensityGrid(ref_ptr<Grid1f> densityGrid);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceDensityGrid1D: public SourceFeature {
           ref_ptr<Grid1f> grid;   // 1D grid with Ny = Nz = 1
   public:
           SourceDensityGrid1D(ref_ptr<Grid1f> densityGrid);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceIsotropicEmission: public SourceFeature {
   public:
           SourceIsotropicEmission();
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceDirectedEmission: public SourceFeature {
           Vector3d mu; // Mean emission direction in the vMF distribution
           double kappa; // Concentration parameter of the vMF distribution
   public:
           SourceDirectedEmission(Vector3d mu, double kappa);
           void prepareCandidate(Candidate &candidate) const;
           void setDescription();
   };
   
   class SourceLambertDistributionOnSphere: public SourceFeature {
           Vector3d center;        // center of the sphere
           double radius;          // radius of the sphere
           bool inward;            // if true, direction point inwards
   public:
           SourceLambertDistributionOnSphere(const Vector3d &center, double radius, bool inward);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceDirection: public SourceFeature {
           Vector3d direction;
   public:
           SourceDirection(Vector3d direction = Vector3d(-1, 0, 0));
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   };
   
   
   class SourceEmissionMap: public SourceFeature {
           ref_ptr<EmissionMap> emissionMap;
   public:
           SourceEmissionMap(EmissionMap *emissionMap);
           void prepareCandidate(Candidate &candidate) const;
           void setEmissionMap(EmissionMap *emissionMap);
           void setDescription();
   };
   
   
   class SourceEmissionCone: public SourceFeature {
           Vector3d direction;
           double aperture;
   public:
           SourceEmissionCone(Vector3d direction, double aperture);
           void prepareParticle(ParticleState &particle) const;
   
           void setDirection(Vector3d direction);
           void setDescription();
   };
   
   
   class SourceRedshift: public SourceFeature {
           double z;
   public:
           SourceRedshift(double z);
           void prepareCandidate(Candidate &candidate) const;
           void setDescription();
   };
   
   
   class SourceUniformRedshift: public SourceFeature {
           double zmin, zmax;
   public:
           SourceUniformRedshift(double zmin, double zmax);
           void prepareCandidate(Candidate &candidate) const;
           void setDescription();
   };
   
   
   class SourceRedshiftEvolution: public SourceFeature {
           double zmin, zmax;
           double m;
   public:
           SourceRedshiftEvolution(double m, double zmin, double zmax);
           void prepareCandidate(Candidate &candidate) const;
   };
   
   
   class SourceRedshift1D: public SourceFeature {
   public:
           SourceRedshift1D();
           void prepareCandidate(Candidate &candidate) const;
           void setDescription();
   };
   
   
   #ifdef CRPROPA_HAVE_MUPARSER
   class SourceGenericComposition: public SourceFeature {
   public:
           struct Nucleus {
                   int id;
                   std::vector<double> cdf;
           };
           SourceGenericComposition(double Emin, double Emax, std::string expression, size_t bins = 1024);
           void add(int id, double abundance);
           void add(int A, int Z, double abundance);
           void prepareParticle(ParticleState &particle) const;
           void setDescription();
   
           const std::vector<double> *getNucleusCDF(int id) const {
                   for (size_t i = 0; i < nuclei.size(); i++) {
                           if (nuclei[i].id == id)
                                   return &nuclei[i].cdf;
                   }
                   return 0;
           }
   
   protected:
           double Emin, Emax;
           size_t bins;
           std::string expression;
           std::vector<double> energy;
   
           std::vector<Nucleus> nuclei;
           std::vector<double> cdf;
   
   };
   #endif
   
   class SourceTag: public SourceFeature {
   private:
           std::string sourceTag;
   
   public:
           SourceTag(std::string tag);
           void prepareCandidate(Candidate &candidate) const;
           void setDescription();
           void setTag(std::string tag);
   };
   
   class SourceMassDistribution: public SourceFeature {
   private: 
           ref_ptr<Density> density;       //< density distribution
           double maxDensity;                      //< maximal value of the density in the region of interest
           double xMin, xMax;                      //< x-range to sample positions
           double yMin, yMax;                      //< y-range to sample positions
           double zMin, zMax;                      //< z-range to sample positions
           int maxTries = 10000;           //< maximal number of tries to sample the position 
   
   public: 
           SourceMassDistribution(ref_ptr<Density> density, double maxDensity = 0, double x = 20 * kpc, double y = 20 * kpc, double z = 4 * kpc);
   
           void prepareParticle(ParticleState &particle) const;
   
           void setMaximalDensity(double maxDensity);
   
           void setXrange(double xMin, double xMax);
   
           void setYrange(double yMin, double yMax);
   
           void setZrange(double zMin, double zMax);
   
           /*      samples the position. Can be used for testing.
                   @return Vector3d with sampled position
           */
           Vector3d samplePosition() const;
   
   
           void setMaximalTries(int tries);
   
           std::string getDescription();
   };
    // end of group SourceFeature
   
   } // namespace crpropa
   
   #endif // CRPROPA_SOURCE_H
