"""
- The purpose of this script is to centrally generate all interaction files needed by
  CRPropa relevant to a Blackbody photon field of custom temperature.
- This script has incorporated all calc_<interaction> files contained in crpropa-data,
  thus credit belongs to the authors of the respective code writers.
- MultiCore processing supported
- NOTE: spectrum_<Blackbody>.txt for ~/src/crpropa/ElectronPairProduction can NOT be 
  generated by this script, as these appear to get constructed from data provided by 
  CRPropa2 scripts. As all spectrum scripts appear to only continue zeros or values
  very close to zero, a copy of spectrum_CMB.txt is used throughout.
- Data generated by this script has to be copied to their proper locations in
  ~/src/crpropa/<folder>
- Best way to execute is: python -W ignore calc_all_blackbody_sharefiles.py
- Questions to mario.hoerbe@rub.de

Usage:
  calc_all_blackbody_sharefiles.py (-t | --t_bb <T_BB>)
  calc_all_blackbody_sharefiles.py -h | --help

 Options:
   -h, --help       Show this message.
   -t, --t_bb       Blackbody temperature string in eV. Can be a list of specifiers, e.g. [1,5.3,2e4,...]
   --version        Show version
"""

from __future__ import division
from multiprocessing import Process, cpu_count
import os, sys
from joblib import Parallel, delayed
import numpy as np
import interactionRate as iR
from scipy import integrate
from docopt import docopt
import re

eV = 1.60217657e-19  # [J]
erg = 1e-7  # [J]
c0 = 299792458  # [m/s]
h = 6.62606957e-34  # [m^2 kg / s]
kB = 1.3806488e-23  # [m^2 kg / s^2 / K]


class photonField_Blackbody:
    """
    Blackbody photon field, identical to CMB except for another temperature T_BB.
    Can be used for accretion disc photon fields
    """

    def __init__(self, T_BB_in_eV):
        self.T_BB_in_eV = T_BB_in_eV
        self.T_BB_in_K = T_BB_in_eV * (2*eV/3/kB)
        self.name = 'Blackbody'
        self.info = 'Blackbody_' + str(T_BB_in_eV) + "eV"
        self.redshift = None

    def getDensity(self, eps, z=0):
        """
        Comoving spectral number density dn/deps [1/m^3/J] at given photon energy eps [J] and redshift z.
        Multiply with (1+z)^3 for the physical number density.
        """
        return 8*np.pi / c0**3 / h**3 * eps**2 / (np.exp(eps/(kB*self.T_BB_in_K)) - 1)

    def getEmin(self, z=0):
        """Minimum effective photon energy in [J]"""
        return 1e-10 * eV

    def getEmax(self, z=0):
        """Maximum effective photon energy in [J]"""
        return 0.1 * eV


class Interactions:
    """
    Class containing all interaction calculations that provide shared .txt data to CRPRopa
    """


    def calc_elasticscattering(self):
        # output folder
        folder = outdir + 'ElasticScattering'
        if not os.path.exists(folder):
            os.makedirs(folder)

        gamma = np.logspace(6, 14, 201)  # tabulated UHECR Lorentz-factors

        # load cross section data from TALYS
        ddir = 'tables/PD_Talys1.8_Khan/'
        eps = np.genfromtxt(ddir + 'eps_elastic.txt') * eV * 1e6  # nuclear rest frame photon energies [J]
        data = np.genfromtxt(ddir + 'xs_elastic.txt', dtype=[('Z', int), ('N', int), ('xs', '%if8' % len(eps))])

        # only consider TALYS cross sections for A >= 12
        idx = (data['Z'] + data['N']) >= 12
        data = data[idx]

        # factor out the principal scaling given by the TRK formula: sigma_int ~ Z*N/A
        data['xs'] /= (data['Z'] * data['N'] / (data['Z'] + data['N']))[:, np.newaxis]

        # pad cross sections to next larger 2^n + 1 tabulation points for Romberg integration
        eps = iR.romb_pad_logspaced(eps, 513)
        xs = np.array([iR.romb_pad_zero(x, 513) for x in data['xs']]) * 1e-31

        for field in fields:
            # print("\rcalc_elasticscattering: field: {} ... ".format(field.name))

            # calculate the interaction rate, averaged over all isotopes
            rate = np.mean([iR.calc_rate_eps(eps, x, gamma, field) for x in xs], axis=0)
            fname = folder + '/rate_%s.txt' % field.name.split('_')[0][:3] # [:3] added to be readable by respective .cpp file
            header = 'Average interaction rate for elastic scattering of %s photons off nuclei\nScale with Z*N/A for nuclei\n1/lambda [1/Mpc] for log10(gamma) = 6-14 in 201 steps' % field.info
            np.savetxt(fname, rate, fmt='%g', header=header)

            # calculate CDF for background photon energies, averaged over all isotopes
            CDF = np.zeros((len(gamma), len(eps)))
            for x in xs:
                C = iR.calc_rate_eps(eps, x, gamma, field, cdf=True)
                CDF += C / np.max(C, axis=1, keepdims=True)
            CDF /= len(data)
            CDF = np.nan_to_num(CDF)

            fname = folder + '/cdf_%s.txt' % field.name.split('_')[0][:3] # [:3] added to be readable by respective .cpp file 
            data = np.c_[np.log10(gamma), CDF]
            fmt = '%g' + '\t%g' * len(eps)
            header = '# Average CDF(background photon energy) for elastic scattering with the %s\n# log10(gamma), (1/lambda)_cumulative for eps = log10(2 keV) - log10(263 MeV) in 513 steps' % field.info
            np.savetxt(fname, data, fmt=fmt, header=header)
        # print("\rcalc_elasticscattering: field: {} ... DONE".format(field.name))

    def calc_electromagnetic(self):

        me2 = (510.998918E3 * eV)**2  # squared electron mass [J^2/c^4]
        sigmaThompson = 6.6524E-29  # Thompson cross section [m^2]
        alpha = 1 / 137.035999074  # fine structure constant


        def sigmaPP(s):
            """ Pair production cross section (Bethe-Heitler), see Lee 1996 """
            smin = 4 * me2
            if (s < smin):
                return 0
            else:
                b = np.sqrt(1 - smin / s)
                return sigmaThompson * 3 / 16 * (1 - b**2) * ((3 - b**4) * np.log((1 + b) / (1 - b)) - 2 * b * (2 - b**2))


        def sigmaDPP(s):
            """ Double-pair production cross section, see R.W. Brown eq. (4.5) with k^2 = q^2 = 0 """
            smin = 16 * me2
            if (s < smin):
                return 0
            else:
                return 6.45E-34 * (1 - smin / s)**6


        def sigmaICS(s):
            """ Inverse Compton scattering cross sections, see Lee 1996 """
            smin = me2
            if (s < smin):  # numerically unstable close to smin
                return 0
            else:
                # note: formula unstable for (s - smin) / smin < 1E-5
                b = (s - smin) / (s + smin)
                A = 2 / b / (1 + b) * (2 + 2 * b - b**2 - 2 * b**3)
                B = (2 - 3 * b**2 - b**3) / b**2 * np.log((1 + b) / (1 - b))
                return sigmaThompson * 3 / 8 * smin / s / b * (A - B)
 

        def sigmaTPP(s):
            """ Triplet-pair production cross section, see Lee 1996 """
            beta = 28 / 9 * np.log(s / me2) - 218 / 27
            if beta < 0:
                return 0
            else:
                return sigmaThompson * 3 / 8 / np.pi * alpha * beta


        def getTabulatedXS(sigma, skin):
            """ Get crosssection for tabulated s_kin """
            if sigma in (sigmaPP, sigmaDPP):  # photon interactions
                return np.array([sigma(s) for s in skin])
            if sigma in (sigmaTPP, sigmaICS):  # electron interactions
                return np.array([sigma(s) for s in skin + me2])
            return False


        def getSmin(sigma):
            """ Return minimum required s_kin = s - (mc^2)^2 for interaction """
            return {sigmaPP: 4 * me2,
                    sigmaDPP: 16 * me2,
                    sigmaTPP: np.exp((218 / 27) / (28 / 9)) * me2 - me2,
                    sigmaICS: 1E-9 * me2
                    }[sigma]


        def getEmin(sigma, field):
            """ Return minimum required cosmic ray energy for interaction *sigma* with *field* """
            return getSmin(sigma) / 4 / field.getEmax()


        def process(sigma, field, name):
            # output folder
            folder = outdir + name
            if not os.path.exists(folder):
                os.makedirs(folder)

            # tabulated energies, limit to energies where the interaction is possible
            Emin = getEmin(sigma, field)
            E = np.logspace(10, 23, 261) * eV
            E = E[E > Emin]

            # -------------------------------------------
            # calculate interaction rates
            # -------------------------------------------
            # tabulated values of s_kin = s - mc^2
            # Note: integration method (Romberg) requires 2^n + 1 log-spaced tabulation points
            s_kin = np.logspace(6, 23, 2049) * eV**2
            xs = getTabulatedXS(sigma, s_kin)
            rate = iR.calc_rate_s(s_kin, xs, E, field)

            # save
            fname = folder + '/rate_%s.txt' % field.name
            data = np.c_[np.log10(E / eV), rate]
            fmt = '%.2f\t%.6g'
            header = '%s interaction rates\nphoton field: %s\nlog10(E/eV), 1/lambda [1/Mpc]' % (name, field.info)
            np.savetxt(fname, data, fmt=fmt, header=header)

            # -------------------------------------------
            # calculate cumulative differential interaction rates for sampling s values
            # -------------------------------------------
            # find minimum value of s_kin
            skin1 = getSmin(sigma)  # s threshold for interaction
            skin2 = 4 * field.getEmin() * E[0]  # minimum achievable s in collision with background photon (at any tabulated E)
            skin_min = max(skin1, skin2)

            # tabulated values of s_kin = s - mc^2, limit to relevant range
            # Note: use higher resolution and then downsample
            skin = np.logspace(6.2, 23, 1680 + 1) * eV**2
            skin = skin[skin > skin_min]

            xs = getTabulatedXS(sigma, skin)
            rate = iR.calc_rate_s(skin, xs, E, field, cdf=True)

            # downsample
            skin_save = np.logspace(6.2, 23, 168 + 1) * eV**2
            skin_save = skin_save[skin_save > skin_min]
            rate_save = np.array([np.interp(skin_save, skin, r) for r in rate])

            # save
            data = np.c_[np.log10(E / eV), rate_save]  # prepend log10(E/eV) as first column
            row0 = np.r_[0, np.log10(skin_save / eV**2)][np.newaxis]
            data = np.r_[row0, data]  # prepend log10(s_kin/eV^2) as first row

            fname = folder + '/cdf_%s.txt' % field.name
            fmt = '%.2f' + '\t%.6g' * np.shape(rate_save)[1]
            header = '%s cumulative differential rate\nphoton field: %s\nlog10(E/eV), d(1/lambda)/ds_kin [1/Mpc/eV^2] for log10(s_kin/eV^2) as given in first row' % (name, field.info)
            np.savetxt(fname, data, fmt=fmt, header=header)

        for field in fields:
            # print("\rcalc_electromagnetic: field: {} ... DONE".format(field.name))
            Process(target=process, args=([sigmaPP, field, 'EMPairProduction'])).start()
            Process(target=process, args=([sigmaPP, field, 'EMDoublePairProduction'])).start()
            Process(target=process, args=([sigmaPP, field, 'EMTripletPairProduction'])).start()
            Process(target=process, args=([sigmaPP, field, 'EMInverseComptonScattering'])).start()
        # print("\rcalc_electromagnetic: field: {} ... DONE".format(field.name))


    def calc_pairproduction(self):
        """
        Calculate the energy loss rate through electron pair production
        References:
        (B70) Blumenthal 1970, Phys.Rev. D
        (C92) Chodorowski et al. 1992, ApJ 400:181-185
        """

        Mpc = 3.08567758e22  # [m]
        r0 = 2.817940e-15  # classical electron radius [m]
        alpha = 7.297352e-3  # fine-structure constant
        me = 9.10938291e-31  # electron mass [kg]
        me_c2 = me * c0**2  # electron mass in [J/c^2]
        mp = 1.67262178e-27  # proton mass [kg]


        def lossRate(gamma, field, z=0):
            """
            Loss rate from electron pair production with the given photon background, cf. C92, equation 3.11
            gamma   : list of nucleus Lorentz factors
            field   : photon background
            z       : redshift
            Returns : 1/gamma dgamma/dx [1/Mpc]
            """

            def phi(k):
                """
                Parametrization of the integral 3.12 (C92)
                """
                _c = np.array([0.8048, 0.1459, 1.137e-3, -3.879e-6])
                _d = np.array([-86.07, 50.96, -14.45, 8 / 3.])
                _f = np.array([2.910, 78.35, 1837])
                # phi(k) for k < 25, eq. 3.14
                if k < 25:
                    return np.pi / 12 * (k - 2)**4 / (1 + sum(_c * (k - 2)**np.arange(1, 5)))
                # phi(k) for k > 25, eq. 3.18 and 3.16
                return k * sum(_d * np.log(k)**np.arange(4)) / (1 - sum(_f * k**-np.arange(1, 4)))

            def integrand(logk, gamma, field):
                """
                Integrand of equation 3.11 (C92), logarithmic version
                logk  : ln(k) = ln(2 gamma eps / (me c^2)), photon energy
                gamma : nucleus Lorentz factor
                field : photon background
                """
                k = np.exp(logk)
                eps = k * me_c2 / 2 / gamma  # photon energy [J] in lab frame
                n = field.getDensity(eps, z)  # spectral number density [1/m^3/J]
                n *= me_c2  # from substitution d eps / d k
                return n * phi(k) / k  # includes *k from substitution k -> ln(k)

            rate = np.zeros_like(gamma)
            err = np.zeros_like(gamma)

            # minimum and maximum energy of the fields photons in units of me*c^2
            epsmin = field.getEmin() / me_c2
            epsmax = field.getEmax() / me_c2

            for i, g in enumerate(gamma):
                lkmin = np.log(max(2, 2 * g * epsmin))
                lkmax = np.log(2 * g * epsmax)
                lksep = np.linspace(lkmin, lkmax, 11)[1:-1]
                rate[i], err[i] = integrate.quad(
                    integrand, lkmin, lkmax, points=lksep, args=(g, field))

            # prefactor of equation 3.11 (C92) and conversion [1/s] --> [1/Mpc]
            a = alpha * r0**2 * me / mp * Mpc
            return a * rate / gamma, a * err / gamma


        # -------------------------------------------------
        # Generate tables for energy loss rate
        # -------------------------------------------------
        gamma = np.logspace(6, 14, 161)  # tabulated Lorentz factors

        folder = outdir + 'ElectronPairProduction'
        if not os.path.exists(folder):
            os.makedirs(folder)

        for field in fields:
            # print("\rcalc_pairproduction: field: {}\n".format(field.name))
            rate = lossRate(gamma, field)[0]
            s = (rate > 1e-12)  # truncate if loss rate is < 10^-12 / Mpc

            fname = folder + '/lossrate_%s.txt' % field.name
            data = np.c_[np.log10(gamma[s]), rate[s]]
            fmt = '%.2f\t%.6e'
            header = 'Loss rate for electron-pair production with the %s\nlog10(gamma)\t1/gamma dgamma/dx [1/Mpc]' % field.info
            np.savetxt(fname, data, fmt=fmt, header=header)
        # print("\rdone pairprodution\n")

    def calc_photodisintigration(self):
        # print("Photodisintegration")
        gamma = np.logspace(6, 14, 201)  # tabulated UHECR Lorentz-factors


        # ----------------------------------------------------
        # Load cross sections for A < 12
        # ----------------------------------------------------
        ddir1 = 'tables/PD_external/'
        isotopes1 = np.genfromtxt(ddir1 + 'isotopes.txt')
        eps = np.genfromtxt(ddir1 + 'eps.txt')
        d1sum = np.genfromtxt(ddir1 + 'xs_sum.txt', dtype=[('Z', int), ('N', int), ('xs', '%if8' % len(eps))])
        d1exc = np.genfromtxt(ddir1 + 'xs_excl.txt', dtype=[('Z', int), ('N', int), ('ch', int), ('xs', '%if8' % len(eps))])
        # Pad cross sections to next larger 2^n + 1 tabulation points for Romberg integration and convert to SI units
        eps1 = iR.romb_pad_logspaced(eps, 513) * eV * 1e6
        xs1sum = np.array([iR.romb_pad_zero(x, 513) for x in d1sum['xs']]) * 1e-31
        xs1exc = np.array([iR.romb_pad_zero(x, 513) for x in d1exc['xs']]) * 1e-31


        # ----------------------------------------------------
        # Load cross sections for A >= 12 (TALYS)
        # ----------------------------------------------------
        ddir2 = 'tables/PD_Talys1.8_Khan/'
        isotopes2 = np.genfromtxt(ddir2 + 'isotopes.txt')
        eps = np.genfromtxt(ddir2 + 'eps.txt')
        d2sum = np.genfromtxt(ddir2 + 'xs_pd_sum.txt', dtype=[('Z', int), ('N', int), ('xs', '%if8' % len(eps))])
        d2exc = np.genfromtxt(ddir2 + 'xs_pd_thin.txt', dtype=[('Z', int), ('N', int), ('ch', int), ('xs', '%if8' % len(eps))])
        # Only consider cross sections for A > 12
        d2sum = d2sum[(d2sum['Z'] + d2sum['N']) >= 12]
        d2exc = d2exc[(d2exc['Z'] + d2exc['N']) >= 12]
        # Pad cross sections to next larger 2^n + 1 tabulation points for Romberg integration and convert to SI units
        eps2 = iR.romb_pad_logspaced(eps, 513) * eV * 1e6
        xs2sum = np.array([iR.romb_pad_zero(x, 513) for x in d2sum['xs']]) * 1e-31
        xs2exc = np.array([iR.romb_pad_zero(x, 513) for x in d2exc['xs']]) * 1e-31


        # ----------------------------------------------------
        # Load cross sections with photon emission
        # ----------------------------------------------------
        d3sum = np.genfromtxt(ddir2 + 'xs_photon_sum.txt', dtype=[('Z', int), ('N', int), ('Zd', int), ('Nd', int), ('xs', '%if8' % len(eps))])
        d3exc = np.genfromtxt(ddir2 + 'xs_photon_thin.txt', dtype=[('Z', int), ('N', int), ('Zd', int), ('Nd', int), ('Ephoton', float), ('xs', '%if8' % len(eps))])
        # Pad cross sections to next larger 2^n + 1 tabulation points for Romberg integration and convert to SI units
        eps3 = eps2
        xs3sum = np.array([iR.romb_pad_zero(x, 513) for x in d3sum['xs']]) * 1e-31
        xs3exc = np.array([iR.romb_pad_zero(x, 513) for x in d3exc['xs']]) * 1e-31


        def calc_interaction_rates_and_branching_ratios(fields):


            for field in fields:
                # print("calc_photodisintigration interaction rates: field: {}".format(field.name))

                # output folder
                folder = outdir + 'Photodisintegration'
                if not os.path.exists(folder):
                    os.makedirs(folder)

                # Calculate total interaction rates
                R1 = np.array([iR.calc_rate_eps(eps1, x, gamma, field) for x in xs1sum])
                R2 = np.array([iR.calc_rate_eps(eps2, x, gamma, field) for x in xs2sum])

                np.savetxt(
                    folder + '/rate_%s.txt' % field.name,
                    np.r_[np.c_[d1sum['Z'], d1sum['N'], R1], np.c_[d2sum['Z'], d2sum['N'], R2]],
                    fmt='%i\t%i' + '\t%g' * 201,
                    header='Photodisintegration by the %s\nZ, N, 1/lambda [1/Mpc] for log10(gamma) = 6-14 in 201 steps' % field.info)

                # Calculate branching ratios from exclusive interaction rates
                B1 = np.array([iR.calc_rate_eps(eps1, x, gamma, field) for x in xs1exc])
                B2 = np.array([iR.calc_rate_eps(eps2, x, gamma, field) for x in xs2exc])
                for (Z, N, A) in isotopes1:
                    s = (d1exc['Z'] == Z) * (d1exc['N'] == N)
                    B1[s] /= sum(B1[s])
                for (Z, N, A) in isotopes2:
                    s = (d2exc['Z'] == Z) * (d2exc['N'] == N)
                    B2[s] /= sum(B2[s])
                B1 = np.nan_to_num(B1)  # set to 0 when total cross section is 0
                B2 = np.nan_to_num(B2)

                np.savetxt(
                    folder + '/branching_%s.txt' % field.name,
                    np.r_[np.c_[d1exc['Z'], d1exc['N'], d1exc['ch'], B1], np.c_[d2exc['Z'], d2exc['N'], d2exc['ch'], B2]],
                    fmt='%i\t%i\t%06d' + '\t%g' * 201,
                    header='Photo-disintegration with the %s\nZ, N, channel, branching ratio for log10(gamma) = 6-14 in 201 steps' % field.info)
                # print("done PD.interactionRate")

        def calc_photon_emmission_probablilities(fields):

            for field in fields:
                # print("calc_photodisintigration photon emission probabilities: field: {}".format(field.name))

                ncores = cpu_count()
                with Parallel(ncores, verbose=0) as pool:
                
                    R3 = list(
                        pool(
                            delayed(iR.calc_rate_eps)(eps3, x, gamma, field) for x in xs3sum
                            )
                        )
                with Parallel(ncores, verbose=0) as pool:
                
                    B3 = list(
                        pool(
                            delayed(iR.calc_rate_eps)(eps3, x, gamma, field) for x in xs3exc
                            )
                        )
                R3 = np.array(R3)
                B3 = np.array(B3)
                
                for i in range(len(d3sum)):
                    s = (d3exc['Z'] == d3sum['Z'][i]) * (d3exc['N'] == d3sum['N'][i]) * (d3exc['Zd'] == d3sum['Zd'][i]) * (d3exc['Nd'] == d3sum['Nd'][i])
                    B3[s] /= R3[i]
                B3 = np.nan_to_num(B3)
                
                np.savetxt(
                    (outdir + 'Photodisintegration/photon_emission_%s.txt') % field.name.split('_')[0],
                    np.c_[d3exc['Z'], d3exc['N'], d3exc['Zd'], d3exc['Nd'], d3exc['Ephoton'] * 1e6, B3],
                    fmt='%i\t%i\t%i\t%i\t%g' + '\t%g' * 201,
                    header='Emission probabilities of photons with discrete energies via photo-disintegration with the %s\nZ, N, Z_daughter, N_daughter, Ephoton [eV], emission probability for log10(gamma) = 6-14 in 201 steps' % field.info)
                # print("done PD.probability")

        Process(target=calc_interaction_rates_and_branching_ratios, args=([fields])).start()
        Process(target=calc_photon_emmission_probablilities, args=([fields])).start()
        
        # print("done photo-disintegration")

    def calc_photopionproduction(self):
        lgamma = np.linspace(6, 16, 251)  # tabulated Lorentz factors
        gamma = 10**lgamma

        # ----------------------------------------------------
        # Load proton / neutron cross sections [1/m^2] for tabulated energies [J]
        # truncate to largest length 2^i + 1 for Romberg integration
        # ----------------------------------------------------
        d = np.genfromtxt('tables/PPP/xs_proton.txt', unpack=True)
        eps1 = d[0, :2049] * 1e9 * eV  # [J]
        xs1 = d[1, :2049] * 1e-34  # [m^2]

        d = np.genfromtxt('tables/PPP/xs_neutron.txt', unpack=True)
        eps2 = d[0, :2049] * 1e9 * eV  # [J]
        xs2 = d[1, :2049] * 1e-34  # [m^2]


        for field in fields:
            # print("calc_photopionproduction: field: {}".format(field.name))

            # output folder
            folder = outdir + 'PhotoPionProduction'
            if not os.path.exists(folder):
                os.makedirs(folder)

            # ----------------------------------------------------
            # calculate interaction rates at z=0, default option
            # ----------------------------------------------------
            r1 = iR.calc_rate_eps(eps1, xs1, gamma, field)
            r2 = iR.calc_rate_eps(eps2, xs2, gamma, field)

            fname = folder + '/rate_%s.txt' % field.name
            data = np.c_[lgamma, r1, r2]
            fmt = '%.2f\t%.6e\t%.6e'
            header = ("Photo-pion interaction rate with the %s\nlog10(gamma)"
                      "\t1/lambda_proton [1/Mpc]\t1/lambda_neutron [1/Mpc]" % field.info)
            np.savetxt(fname, data, fmt=fmt, header=header)

            # ----------------------------------------------------
            # calculate redshift dependent interaction rates
            # ----------------------------------------------------
            redshifts = field.redshift
            if redshifts is None:
                continue  # skip CMB
            if len(redshifts) > 100:
                redshifts = redshifts[::10]  # thin out long redshift lists (Finke10)

            data = []
            for z in redshifts:
                r1 = iR.calc_rate_eps(eps1, xs1, gamma, field, z)
                r2 = iR.calc_rate_eps(eps2, xs2, gamma, field, z)
                data.append(np.c_[[z] * len(lgamma), lgamma, r1, r2])

            data = np.concatenate([d for d in data], axis=0)
            np.nan_to_num(data)
            fname = folder + '/rate_%s.txt' % field.name.replace('IRB', 'IRBz')
            fmt = '%.2f\t%.2f\t%.6e\t%.6e'
            header = ("Photo-pion interaction rate for the %s\n (redshift dependent)"
                      "z\tlog10(gamma)\t1/lambda_proton [1/Mpc]\t1/lambda_neutron [1/Mpc]" % field.info)
            np.savetxt(fname, data, fmt=fmt, header=header)

        # print("done PPP")

if __name__ == "__main__":

    args = docopt(__doc__, version='02-14-2018')

    pattern = '[-+]? (?: (?: \d* \. \d+ ) | (?: \d+ \.? ) )(?: [Ee] [+-]? \d+ ) ?'
    tl = re.compile(pattern, re.VERBOSE)
    tl = tl.findall(args["<T_BB>"])
    temperature_list = [float(temp) for temp in tl]
    
    for T_BB in temperature_list:

        fields = [photonField_Blackbody(T_BB_in_eV=T_BB)] # T_BB = Blackbody temperature

        outdir = "data/Blackbody_{}eV/".format(T_BB)
        if not os.path.exists(outdir):
            os.makedirs(outdir)
        else:
            print("NOTE: blackbody files already exist for T_BB = {} eV.".format(T_BB))
            continue
        
        for name, method in Interactions.__dict__.items():
            if callable(method):
                Process(target=method, args=([fields])).start()
